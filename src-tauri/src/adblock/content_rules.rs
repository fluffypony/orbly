/// Utilities for platform-specific content rule application.
///
/// On macOS, the content-blocking JSON generated by `AdblockState` is compiled
/// via `WKContentRuleListStore.compileContentRuleList()` at the Swift/ObjC layer.
/// This module provides the Rust-side interface for generating and caching that JSON.
///
/// On Windows, WebView2's `add_WebResourceRequested` handler can use the engine
/// directly for network-level interception.
///
/// On Linux, WebKitGTK's `WebKitUserContentFilterStore` accepts the same JSON
/// format as macOS's WKContentRuleList.

/// Maximum number of rules Apple allows in a single WKContentRuleList.
/// If we exceed this, rules must be split across multiple lists.
#[cfg(target_os = "macos")]
#[allow(dead_code)]
pub const APPLE_CONTENT_RULE_LIMIT: usize = 50_000;

/// Split content-blocking JSON into chunks that fit Apple's rule limit.
#[cfg(target_os = "macos")]
#[allow(dead_code)]
pub fn split_content_blocking_json(json: &str) -> Result<Vec<String>, String> {
    let rules: Vec<serde_json::Value> =
        serde_json::from_str(json).map_err(|e| format!("Invalid JSON: {}", e))?;

    if rules.len() <= APPLE_CONTENT_RULE_LIMIT {
        return Ok(vec![json.to_string()]);
    }

    let mut chunks = Vec::new();
    for chunk in rules.chunks(APPLE_CONTENT_RULE_LIMIT) {
        let chunk_json =
            serde_json::to_string(chunk).map_err(|e| format!("Serialization error: {}", e))?;
        chunks.push(chunk_json);
    }

    Ok(chunks)
}

/// Apply a content rule list to a webview handle.
/// Called from within `webview.with_webview()` closure on macOS.
///
/// Full implementation requires ObjC bridging to:
/// 1. Get WKWebView's configuration via `[webview configuration]`
/// 2. Get the userContentController
/// 3. Compile via `WKContentRuleListStore.compileContentRuleList()`
/// 4. Add compiled list via `addContentRuleList()`
///
/// This requires objc2-web-kit bindings or manual ObjC FFI.
#[cfg(target_os = "macos")]
#[allow(dead_code, unused_imports)]
pub fn apply_content_rule_to_webview(
    identifier: &str,
    json: &str,
) {
    // These imports verify the objc2-web-kit bindings compile correctly.
    // Full implementation requires Tauri to expose with_webview() on macOS
    // to obtain the WKWebView's WKUserContentController.
    use objc2_foundation::NSString;
    use objc2_web_kit::WKContentRuleListStore;

    log::info!(
        "WKContentRuleList '{}' prepared ({} bytes of JSON) â€” full compilation requires webview handle",
        identifier,
        json.len()
    );
}
