/// Utilities for platform-specific content rule application.
///
/// On macOS, the content-blocking JSON generated by `AdblockState` is compiled
/// via `WKContentRuleListStore.compileContentRuleList()` at the Swift/ObjC layer.
/// This module provides the Rust-side interface for generating and caching that JSON.
///
/// On Windows, WebView2's `add_WebResourceRequested` handler can use the engine
/// directly for network-level interception.
///
/// On Linux, WebKitGTK's `WebKitUserContentFilterStore` accepts the same JSON
/// format as macOS's WKContentRuleList.

/// Maximum number of rules Apple allows in a single WKContentRuleList.
/// If we exceed this, rules must be split across multiple lists.
#[cfg(target_os = "macos")]
#[allow(dead_code)]
pub const APPLE_CONTENT_RULE_LIMIT: usize = 50_000;

/// Split content-blocking JSON into chunks that fit Apple's rule limit.
#[cfg(target_os = "macos")]
#[allow(dead_code)]
pub fn split_content_blocking_json(json: &str) -> Result<Vec<String>, String> {
    let rules: Vec<serde_json::Value> =
        serde_json::from_str(json).map_err(|e| format!("Invalid JSON: {}", e))?;

    if rules.len() <= APPLE_CONTENT_RULE_LIMIT {
        return Ok(vec![json.to_string()]);
    }

    let mut chunks = Vec::new();
    for chunk in rules.chunks(APPLE_CONTENT_RULE_LIMIT) {
        let chunk_json =
            serde_json::to_string(chunk).map_err(|e| format!("Serialization error: {}", e))?;
        chunks.push(chunk_json);
    }

    Ok(chunks)
}

/// Apply a content rule list to a webview handle.
/// Called from within `webview.with_webview()` closure on macOS.
///
/// Full implementation requires ObjC bridging to:
/// 1. Get WKWebView's configuration via `[webview configuration]`
/// 2. Get the userContentController
/// 3. Compile via `WKContentRuleListStore.compileContentRuleList()`
/// 4. Add compiled list via `addContentRuleList()`
///
/// This requires objc2-web-kit bindings or manual ObjC FFI.
#[cfg(target_os = "macos")]
#[allow(dead_code)]
pub fn compile_and_add_rules(
    wk_webview: *mut std::ffi::c_void,
    identifier: &str,
    json: &str,
) {
    use block2::RcBlock;
    use objc2::MainThreadMarker;
    use objc2::rc::Retained;
    use objc2_foundation::{NSError, NSString};
    use objc2_web_kit::{WKContentRuleList, WKContentRuleListStore, WKWebView};

    let mtm = match MainThreadMarker::new() {
        Some(mtm) => mtm,
        None => return,
    };

    let webview_ptr = wk_webview as *mut WKWebView;
    let id_for_log = identifier.to_string();

    // SAFETY: WebKit API is main-thread only; guarded by MainThreadMarker above.
    let store = unsafe { WKContentRuleListStore::defaultStore(mtm) };
    let Some(store) = store else { return };

    let identifier_ns = NSString::from_str(identifier);
    let json_ns = NSString::from_str(json);

    // SAFETY: Callback receives either a compiled list or an NSError from WebKit.
    let completion = RcBlock::new(move |rule_list: *mut WKContentRuleList, error: *mut NSError| {
        if !error.is_null() {
            log::warn!("Failed to compile WKContentRuleList '{}': error returned", id_for_log);
            return;
        }
        if rule_list.is_null() {
            return;
        }
        // SAFETY: Non-null pointer comes from WebKit callback contract.
        let retained = unsafe { Retained::retain(rule_list) };
        let Some(rule_list) = retained else { return };
        // SAFETY: Accessing WKWebView configuration on main thread.
        let webview: &WKWebView = unsafe { &*webview_ptr };
        let config = unsafe { webview.configuration() };
        // SAFETY: Accessing WKUserContentController on main thread.
        let controller = unsafe { config.userContentController() };
        // SAFETY: Adding a compiled rule list to the user content controller.
        unsafe { controller.addContentRuleList(&rule_list) };
    });

    // SAFETY: Calling WebKit API with valid NSString arguments and callback block.
    unsafe {
        store.compileContentRuleListForIdentifier_encodedContentRuleList_completionHandler(
            Some(&identifier_ns),
            Some(&json_ns),
            Some(&completion),
        );
    }
}
