/// Utilities for platform-specific content rule application.
///
/// On macOS, the content-blocking JSON generated by `AdblockState` is compiled
/// via `WKContentRuleListStore.compileContentRuleList()` at the Swift/ObjC layer.
/// This module provides the Rust-side interface for generating and caching that JSON.
///
/// On Windows, WebView2's `add_WebResourceRequested` handler can use the engine
/// directly for network-level interception.
///
/// On Linux, WebKitGTK's `WebKitUserContentFilterStore` accepts the same JSON
/// format as macOS's WKContentRuleList.

/// Maximum number of rules Apple allows in a single WKContentRuleList.
/// If we exceed this, rules must be split across multiple lists.
#[cfg(target_os = "macos")]
#[allow(dead_code)]
pub const APPLE_CONTENT_RULE_LIMIT: usize = 50_000;

/// Split content-blocking JSON into chunks that fit Apple's rule limit.
#[cfg(target_os = "macos")]
#[allow(dead_code)]
pub fn split_content_blocking_json(json: &str) -> Result<Vec<String>, String> {
    let rules: Vec<serde_json::Value> =
        serde_json::from_str(json).map_err(|e| format!("Invalid JSON: {}", e))?;

    if rules.len() <= APPLE_CONTENT_RULE_LIMIT {
        return Ok(vec![json.to_string()]);
    }

    let mut chunks = Vec::new();
    for chunk in rules.chunks(APPLE_CONTENT_RULE_LIMIT) {
        let chunk_json =
            serde_json::to_string(chunk).map_err(|e| format!("Serialization error: {}", e))?;
        chunks.push(chunk_json);
    }

    Ok(chunks)
}
